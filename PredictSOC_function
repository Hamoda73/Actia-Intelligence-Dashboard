#r "Newtonsoft.Json"
#r "System.Security.Cryptography"
using System.Net;
using System.Net.Http;
using System.Text;
using System.Security.Cryptography;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Primitives;
using Newtonsoft.Json;

public static async Task<IActionResult> Run(HttpRequest req, ILogger log)
{
    log.LogInformation("SOC Prediction function triggered");

    try
    {
        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
        
        // Handle empty batch (test connection from Stream Analytics)
        if (string.IsNullOrEmpty(requestBody) || 
            requestBody.Trim() == "[]" || 
            requestBody.Trim() == "{}" || 
            requestBody.Trim() == "" ||
            requestBody.Trim() == "null")
        {
            log.LogInformation("Received empty batch - test connection");
            return new OkObjectResult(new { status = "success", message = "Test connection successful" });
        }

        // Additional safety check - try to parse and see if it's empty
        try 
        {
            var testParse = JsonConvert.DeserializeObject(requestBody);
            if (testParse == null)
            {
                log.LogInformation("Received null data - test connection");
                return new OkObjectResult(new { status = "success", message = "Test connection successful" });
            }
        }
        catch
        {
            // If it fails to parse, might be empty string or invalid, treat as test
            log.LogInformation("Received unparseable data - likely test connection");
            return new OkObjectResult(new { status = "success", message = "Test connection successful" });
        }

        log.LogInformation($"Received data: {requestBody}");

        // Parse incoming data from Stream Analytics
        dynamic streamData = JsonConvert.DeserializeObject(requestBody);
        
        // Buffer to collect 16 records for ML prediction
        // In production, you might want to use Azure Table Storage or Redis for persistence
        // For now, we'll process each record individually and store in CosmosDB
        
        // Process the incoming record
        var record = ProcessStreamAnalyticsRecord(streamData, log);
        
        // Generate ML prediction (simulate for now)
        var prediction = SimulateMLPrediction(record, log);
        
        // Create prediction record for CosmosDB
        var predictionRecord = new 
        {
            id = record.id + "-prediction",
            partitionKey = record.deviceId, // Add partition key field
            deviceId = record.deviceId,
            timestamp = record.timestamp,
            predicted_soc = prediction,
            confidence = 0.85,
            model_version = "v1.0",
            processed_at = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ"),
            // Include original sensor data for reference
            original_soc = record.soc_percent,
            vehicle_state = record.vehicle_state,
            charge_state = record.charge_state,
            battery_voltage = record.pack_voltage,
            motor_current = record.pack_current,
            max_cell_voltage = record.max_cell_voltage,
            min_cell_voltage = record.min_cell_voltage,
            max_temperature = record.max_temperature,
            min_temperature = record.min_temperature
        };
        
        // Store the prediction in CosmosDB soc-predictions container
        await StoreInCosmosDB(predictionRecord, log);
        
        log.LogInformation($"Processed and stored prediction: {prediction} for device {record.deviceId}");
        
        return new OkObjectResult(new { 
            status = "success", 
            message = "Prediction generated and stored",
            recordId = record.id,
            prediction = prediction
        });
    }
    catch (Exception ex)
    {
        log.LogError($"Error processing request: {ex.Message}");
        return new BadRequestObjectResult(new { error = ex.Message });
    }
}

private static dynamic ProcessStreamAnalyticsRecord(dynamic streamData, ILogger log)
{
    // Create a record object with timestamp
    var record = new 
    {
        id = streamData?.id?.ToString() ?? Guid.NewGuid().ToString(),
        deviceId = streamData?.deviceId?.ToString() ?? "unknown",
        timestamp = streamData?.timestamp?.ToString() ?? DateTime.UtcNow.ToString(),
        // Map Stream Analytics fields to our format
        vehicle_state = streamData?.vehicleState?.ToString() ?? "unknown",
        charge_state = streamData?.chargeState?.ToString() ?? "unknown", 
        pack_voltage = Convert.ToDouble(streamData?.batteryVoltage ?? 0),
        pack_current = Convert.ToDouble(streamData?.motorCurrent ?? 0),
        soc_percent = Convert.ToDouble(streamData?.stateOfCharge ?? 0),
        max_cell_voltage = Convert.ToDouble(streamData?.maxCellVoltage ?? 0),
        min_cell_voltage = Convert.ToDouble(streamData?.minCellVoltage ?? 0),
        max_temperature = Convert.ToDouble(streamData?.maxTemperature ?? 0),
        min_temperature = Convert.ToDouble(streamData?.minTemperature ?? 0),
        // Add metadata
        processed_at = DateTime.UtcNow,
        processing_time = streamData?.processingTime?.ToString()
    };
    
    log.LogInformation($"Processed record: {record.id} from device: {record.deviceId}");
    return record;
}

private static double SimulateMLPrediction(dynamic record, ILogger log)
{
    var currentSoc = record.soc_percent;
    var prediction = currentSoc + (new Random().NextDouble() - 0.5) * 2;
    log.LogInformation($"Simulated ML prediction: {prediction} (current SOC: {currentSoc})");
    return Math.Max(0, Math.Min(100, prediction));
}

private static async Task StoreInCosmosDB(dynamic record, ILogger log)
{
    try
    {
        // CosmosDB settings (add these to Function App settings)
        string cosmosEndpoint = Environment.GetEnvironmentVariable("CosmosDB_Endpoint");
        string cosmosKey = Environment.GetEnvironmentVariable("CosmosDB_Key");
        
        log.LogInformation($"CosmosDB_Endpoint: {(string.IsNullOrEmpty(cosmosEndpoint) ? "NOT SET" : "SET")}");
        log.LogInformation($"CosmosDB_Key: {(string.IsNullOrEmpty(cosmosKey) ? "NOT SET" : "SET")}");
        
        if (string.IsNullOrEmpty(cosmosEndpoint) || string.IsNullOrEmpty(cosmosKey))
        {
            log.LogError("CosmosDB settings not found. Record not stored in CosmosDB.");
            log.LogError("Please set CosmosDB_Endpoint and CosmosDB_Key in Function App Configuration");
            return;
        }

        // Call CosmosDB REST API directly
        using (var httpClient = new HttpClient())
        {
            // Prepare CosmosDB REST API call
            string databaseId = "evdata";
            string containerId = "soc-predictions";
            string resourceLink = $"dbs/{databaseId}/colls/{containerId}";
            string resourceType = "docs";
            string verb = "POST";
            
            log.LogInformation($"Attempting to store record {record.id} in CosmosDB");
            log.LogInformation($"Database: {databaseId}, Container: {containerId}");
            
            // Generate authorization header
            string utcDate = DateTime.UtcNow.ToString("r");
            string authHeader = GenerateCosmosAuthHeader(verb, resourceType, resourceLink, utcDate, cosmosKey);
            
            // Clear any existing headers and set required ones
            httpClient.DefaultRequestHeaders.Clear();
            httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            httpClient.DefaultRequestHeaders.Add("Authorization", authHeader);
            httpClient.DefaultRequestHeaders.Add("x-ms-date", utcDate);
            httpClient.DefaultRequestHeaders.Add("x-ms-version", "2018-12-31");
            
            // Prepare the document
            var document = JsonConvert.SerializeObject(record);
            log.LogInformation($"Document to store: {document}");
            
            var content = new StringContent(document, Encoding.UTF8, "application/json");
            
            // Make the API call
            string url = $"{cosmosEndpoint.TrimEnd('/')}/dbs/{databaseId}/colls/{containerId}/docs";
            log.LogInformation($"CosmosDB URL: {url}");
            
            var response = await httpClient.PostAsync(url, content);
            
            log.LogInformation($"CosmosDB Response Status: {response.StatusCode}");
            
            if (response.IsSuccessStatusCode)
            {
                string responseContent = await response.Content.ReadAsStringAsync();
                log.LogInformation($"Successfully stored prediction record {record.id} in CosmosDB");
                log.LogInformation($"Response: {responseContent}");
            }
            else
            {
                string errorContent = await response.Content.ReadAsStringAsync();
                log.LogError($"Failed to store in CosmosDB: {response.StatusCode} - {errorContent}");
                log.LogError($"Request URL: {url}");
                log.LogError($"UTC Date: {utcDate}");
                log.LogError($"Resource Link: {resourceLink}");
            }
        }
    }
    catch (Exception ex)
    {
        log.LogError($"Error storing in CosmosDB: {ex.Message}");
        // Don't throw - we don't want to fail the entire function
    }
}

private static string GenerateCosmosAuthHeader(string verb, string resourceType, string resourceLink, string date, string key)
{
    using (var hmacSha256 = new HMACSHA256(Convert.FromBase64String(key)))
    {
        string payLoad = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}\n{1}\n{2}\n{3}\n{4}\n",
                verb.ToLowerInvariant(),
                resourceType.ToLowerInvariant(),
                resourceLink,
                date.ToLowerInvariant(),
                ""
        );

        byte[] hashPayLoad = hmacSha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(payLoad));
        string signature = Convert.ToBase64String(hashPayLoad);

        // URL encode the authorization string as per documentation
        return WebUtility.UrlEncode($"type=master&ver=1.0&sig={signature}");
    }
}

private static async Task<double?> CallMLModel(List<dynamic> records, ILogger log)
{
    try 
    {
        if (records.Count != 16)
        {
            log.LogWarning($"Need exactly 16 records for ML prediction, got {records.Count}");
            return null;
        }

        // Prepare data for ML model
        var mlPayload = new 
        {
            data = records.Select(r => new 
            {
                vehicle_state = r.vehicle_state,
                charge_state = r.charge_state,
                pack_voltage_v = r.pack_voltage,  // Note: field name format for ML model
                pack_current_a = r.pack_current,
                soc_percent = r.soc_percent,      // Note: field name format
                max_cell_voltage_v = r.max_cell_voltage,
                min_cell_voltage_v = r.min_cell_voltage,
                max_probe_temperature_c = r.max_temperature,  // Note: field name format
                min_probe_temperature_c = r.min_temperature
            }).ToArray()
        };

        using (var httpClient = new HttpClient())
        {
            httpClient.DefaultRequestHeaders.Add("Authorization", 
                "Bearer ");
            
            var json = JsonConvert.SerializeObject(mlPayload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await httpClient.PostAsync(
                "https://actia-okzir.canadacentral.inference.ml.azure.com/score", 
                content);
            
            if (response.IsSuccessStatusCode)
            {
                var responseBody = await response.Content.ReadAsStringAsync();
                dynamic result = JsonConvert.DeserializeObject(responseBody);
                
                log.LogInformation($"ML Prediction successful: {result.predicted_soc}");
                return Convert.ToDouble(result.predicted_soc);
            }
            else 
            {
                log.LogError($"ML API call failed: {response.StatusCode} - {await response.Content.ReadAsStringAsync()}");
                return null;
            }
        }
    }
    catch (Exception ex)
    {
        log.LogError($"Error calling ML model: {ex.Message}");
        return null;
    }
}
